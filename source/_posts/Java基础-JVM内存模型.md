---
title: Java基础-JVM内存模型
date: 2018-03-03 19:59:55
tags: [java,java基础,jvm]
categories: [Java基础]
---

* JRE（JavaRuntimeEnvironment，Java运行环境）也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。
* JDK（Java Development Kit）是程序开发者用来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。
* JVM（JavaVirtualMachine，Java虚拟机）是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。


![avatar](http://wx2.sinaimg.cn/large/007h1WTYly1fysn56thu0j30sg0h9tdz.jpg)


### 内存模型

#### 程序计数器
&#160; &#160; &#160; &#160;**程序计数器是一块较小的内存空间，可以看作是当前线程所执行的（正在执行）字节码的行号指示器**。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。

&#160; &#160; &#160; &#160;由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个**独立**的程序计数器，**各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。它的生命周期与线程相同**

&#160; &#160; &#160; &#160;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。

#### 栈
##### Java虚拟机栈
与程序计数器一样，Java虚拟机栈也是**线程私有的**，**它的生命周期和线程相同**，**描述的是Java方法执行的内存模型**：每一个方法执行的同时都会创建一个栈帧（Stack Frame），用来存储局部变量表、操作数栈，动态链接，方法出口等信息。每个方法从调用到执行完成的过程，都对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

Java内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

**局部变量表主要存放了编译器可知的各种基本数据类型、对象引用**。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

StackOverflowError：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常

##### 本地方法栈

本地方法栈为虚拟使用到Native方法服务。

#### 堆

Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程所共享的一块内存区域，在虚拟机启动是创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。**

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

堆模型图
![avatar](http://wx4.sinaimg.cn/large/007h1WTYly1fysn51qwu5j30s30azmyo.jpg)

#### 方法区

方法区与 Java 堆一样，是**各个线程共享的内存区域**，它用于**存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**

**注**：**在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。**

#### 运行时常量池

运行时常量池时方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

#### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。



### JVM常用参数的含义

| 参数名称        | 含义                        |
| --------------- | --------------------------- |
| -Xms            | 初始堆大小                  |
| -Xmx            | 最大堆                      |
| -Xmn            | 年轻代大小（1.4 or later）  |
| -XX:NewSize     | 设置年轻代大小(for 1.3/1.4) |
| -XX:MaxNewSize  | 年轻代最大值(for 1.3/1.4)   |
| -XX:PermSize    | 设置持久代(perm gen)初始值  |
| -XX:MaxPermSize | 设置持久代最大值            |
| -Xss            | 每个线程的堆栈大小          |



