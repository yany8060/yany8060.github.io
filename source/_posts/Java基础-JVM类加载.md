---
title: Java基础-JVM类加载
date: 2018-04-12 20:52:17
tags: [java,java基础,jvm]
categories: [Java基础]
---



### 类加载过程
> **JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化**

![avatar](http://wx4.sinaimg.cn/mw690/007h1WTYly1fz0dp4k541j30w00astab.jpg)

#### 加载

1. 通过一个类的全限定名来获取其定义的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。


> JVM中的ClassLoader类加载器加载Class发生在此阶段
> 
> 这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也**可以在运行时计算生成（动态代理）**，也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。


#### 验证
验证的目的是为了**确保Class文件中的字节流包含的信息符合当前虚拟机的要求**，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：**文件格式的验证、元数据的验证、字节码验证和符号引用验证**。

* 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
* 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
* 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
* 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。


#### 准备
准备阶段是正式为**类变量（static变量）**分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

假设一个类变量的定义为：

```java
public static int value = 3；
```
那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit\>（）方法之中的，**所以把value赋值为3的动作将在初始化阶段才会执行。**



> final、static、static final修饰的字段赋值的区别：
>
> - static修饰的字段在类加载过程中的准备阶段被初始化为0或null等默认值，而后在初始化阶段（触发类构造器<clinit\>）才会被赋予代码中设定的值，如果没有设定值，那么它的值就为默认值。
> - final修饰的字段在运行时被初始化（可以直接赋值，也可以在实例构造器中赋值），一旦赋值便不可更改；
> - static final修饰的字段在Javac时生成ConstantValue属性，在类加载的准备阶段根据ConstantValue的值为该字段赋值，它没有默认值，必须显式地赋值，否则Javac时会报错。可以理解为在编译期即把结果放入了常量池中。



#### 解析

**把类中的符号引用转换为直接引用**。解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。

解析动作主要：
1. 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。
2. 字段解析：字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会**按照继承关系从上往下递归搜索**该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
3. 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。
4. 接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。



>- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
>
>- 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。

#### 初始化

* 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。
* 初始化阶段是执行类构造器<client\>方法的过程。<client\>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client\>方法执行之前，父类的<client\>方法已经执行完毕。

**<clinit\>（）方法的执行规则:**

1. <clinit>（）方法是由编译器自动收集类中的**所有类变量的赋值动作和静态语句块中的语句**合并产生的，编译器收集的顺序是由语句在**源文件中出现的顺序**所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。
2.  <clinit\>（）方法与实例构造器<init\>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，**虚拟机会保证在子类的<clinit\>（）方法执行之前，父类的<clinit\>（）方法已经执行完毕**。因此，在虚拟机中第一个被执行的<clinit\>（）方法的类肯定是java.lang.Object。
3. <clinit\>（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit\>（）方法。
4. 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此**接口与类一样会生成<clinit\>（）方法**。但是接口类不同的是：执行接口的<clinit\>（）方法不需要先执行父接口的<clinit\>（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit\>（）方法。
5. **虚拟机会保证一个类的<clinit\>（）方法在多线程环境中被正确地加锁和同步**，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit\>（）方法，其他线程都需要阻塞等待，直到活动线程执行<clinit\>（）方法完毕。如果在一个类的<clinit\>（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的

### 类加载器
* 启动类加载器（Bootstrap ClassLoader）
* 扩展类加载器（Extension ClassLoader）
* 应用程序类加载器（Application ClassLoader）
* 自定义类加载器

![avatar](http://wx3.sinaimg.cn/mw690/007h1WTYly1fz0dozllubj30ge0db3zn.jpg)

#### 双亲委派模型
#### 工作流程
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

![avatar](http://wx4.sinaimg.cn/mw690/007h1WTYly1fz0dovr832j305w0c6glq.jpg)

#### 机制

1. 当ApplicationClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtensionClassLoader去完成。
2. 当ExtensionClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
3. 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtensionClassLoader来尝试加载；
4. 若ExtensionClassLoader也加载失败，则会使用ApplicationClassLoader来加载，如果ApplicationClassLoader也加载失败，则会报出异常ClassNotFoundException。



#### 系统安全性

Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，**最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类**。如果不采用双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object类。